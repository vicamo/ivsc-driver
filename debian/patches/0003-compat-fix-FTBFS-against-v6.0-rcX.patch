From: "You-Sheng Yang (vicamo)" <vicamo.yang@canonical.com>
Date: Wed, 24 Aug 2022 17:47:46 +0800
Subject: compat: fix FTBFS against v6.0-rcX

Signed-off-by: You-Sheng Yang (vicamo) <vicamo.yang@canonical.com>
---
 drivers/i2c/busses/i2c-ljca.c | 49 ++++++++++++++++++++++++++++++++-----------
 drivers/mfd/ljca.c            | 33 +++++++++++++++++++++--------
 drivers/misc/mei/spi-vsc.c    | 24 ++++++++++++++++++---
 3 files changed, 82 insertions(+), 24 deletions(-)

diff --git a/drivers/i2c/busses/i2c-ljca.c b/drivers/i2c/busses/i2c-ljca.c
index ea2f4bb..893ff87 100644
--- a/drivers/i2c/busses/i2c-ljca.c
+++ b/drivers/i2c/busses/i2c-ljca.c
@@ -10,6 +10,7 @@
 #include <linux/mfd/ljca.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/version.h>
 
 /* I2C commands */
 enum i2c_cmd {
@@ -322,42 +323,66 @@ static const struct i2c_algorithm ljca_i2c_algo = {
 	.functionality = ljca_i2c_func,
 };
 
+struct bind_acpi_data {
+	struct ljca_i2c_dev *ljca_i2c;
+	const char *hid1;
+	const char *uid1;
+	char uid2[2];
+};
+
+static int try_bind_acpi_entry(struct acpi_device *adev, void *vdata)
+{
+	struct bind_acpi_data *data = (struct bind_acpi_data *)vdata;
+
+	if (acpi_dev_hid_uid_match(adev, data->hid1, data->uid2)) {
+		ACPI_COMPANION_SET(&data->ljca_i2c->adap.dev, adev);
+		return 1;
+	}
+
+	return 0;
+}
+
 static void try_bind_acpi(struct platform_device *pdev,
 			  struct ljca_i2c_dev *ljca_i2c)
 {
-	struct acpi_device *parent, *child;
+	struct acpi_device *parent;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6,0,0))
+	struct acpi_device *child;
+#endif
 	struct acpi_device *cur = ACPI_COMPANION(&pdev->dev);
-	const char *hid1;
-	const char *uid1;
-	char uid2[2] = { 0 };
+	struct bind_acpi_data data = { .uid2 = {0} };
 
 	if (!cur)
 		return;
 
-	hid1 = acpi_device_hid(cur);
-	uid1 = acpi_device_uid(cur);
-	snprintf(uid2, sizeof(uid2), "%d", ljca_i2c->ctr_info->id);
+	data.hid1 = acpi_device_hid(cur);
+	data.uid1 = acpi_device_uid(cur);
+	snprintf(data.uid2, sizeof(data.uid2), "%d", ljca_i2c->ctr_info->id);
 
 	/*
 	* If the pdev is bound to the right acpi device, just forward it to the
 	* adapter. Otherwise, we find that of current adapter manually.
 	*/
-	if (!uid1 || !strcmp(uid1, uid2)) {
+	if (!data.uid1 || !strcmp(data.uid1, data.uid2)) {
 		ACPI_COMPANION_SET(&ljca_i2c->adap.dev, cur);
 		return;
 	}
 
-	dev_dbg(&pdev->dev, "hid %s uid %s new uid%s\n", hid1, uid1, uid2);
+	dev_dbg(&pdev->dev, "hid %s uid %s new uid%s\n",
+			data.hid1, data.uid1, data.uid2);
 	parent = ACPI_COMPANION(pdev->dev.parent);
 	if (!parent)
 		return;
 
+	data.ljca_i2c = ljca_i2c;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6,0,0))
 	list_for_each_entry(child, &parent->children, node) {
-		if (acpi_dev_hid_uid_match(child, hid1, uid2)) {
-			ACPI_COMPANION_SET(&ljca_i2c->adap.dev, child);
+		if (try_bind_acpi_entry(child, &data))
 			return;
-		}
 	}
+#else
+	acpi_dev_for_each_child(parent, try_bind_acpi_entry, &data);
+#endif
 }
 
 static int ljca_i2c_probe(struct platform_device *pdev)
diff --git a/drivers/mfd/ljca.c b/drivers/mfd/ljca.c
index 24404ff..7146cb9 100644
--- a/drivers/mfd/ljca.c
+++ b/drivers/mfd/ljca.c
@@ -16,6 +16,7 @@
 #include <linux/types.h>
 #include <linux/uaccess.h>
 #include <linux/usb.h>
+#include <linux/version.h>
 
 enum ljca_acpi_match_adr {
 	LJCA_ACPI_MATCH_GPIO,
@@ -225,24 +226,38 @@ static int try_match_acpi_hid(struct acpi_device *child,
 	return 0;
 }
 
+static int precheck_acpi_hid_entry(struct acpi_device *adev, void *not_used)
+{
+	try_match_acpi_hid(adev, &ljca_acpi_match_gpio, gpio_hids,
+			   ARRAY_SIZE(gpio_hids));
+	try_match_acpi_hid(adev, &ljca_acpi_match_i2cs[0], i2c_hids,
+			   ARRAY_SIZE(i2c_hids));
+	try_match_acpi_hid(adev, &ljca_acpi_match_i2cs[1], i2c_hids,
+			   ARRAY_SIZE(i2c_hids));
+	try_match_acpi_hid(adev, &ljca_acpi_match_spis[0], spi_hids,
+			   ARRAY_SIZE(spi_hids));
+
+	return 0;
+}
+
 static int precheck_acpi_hid(struct usb_interface *intf)
 {
-	struct acpi_device *parent, *child;
+	struct acpi_device *parent;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6,0,0))
+	struct acpi_device *child;
+#endif
 
 	parent = ACPI_COMPANION(&intf->dev);
 	if (!parent)
 		return -ENODEV;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6,0,0))
 	list_for_each_entry (child, &parent->children, node) {
-		try_match_acpi_hid(child, &ljca_acpi_match_gpio, gpio_hids,
-				   ARRAY_SIZE(gpio_hids));
-		try_match_acpi_hid(child, &ljca_acpi_match_i2cs[0], i2c_hids,
-				   ARRAY_SIZE(i2c_hids));
-		try_match_acpi_hid(child, &ljca_acpi_match_i2cs[1], i2c_hids,
-				   ARRAY_SIZE(i2c_hids));
-		try_match_acpi_hid(child, &ljca_acpi_match_spis[0], spi_hids,
-				   ARRAY_SIZE(spi_hids));
+		precheck_acpi_hid_entry(child, NULL);
 	}
+#else
+	acpi_dev_for_each_child(parent, precheck_acpi_hid_entry, NULL);
+#endif /* >= 5.18 */
 
 	return 0;
 }
diff --git a/drivers/misc/mei/spi-vsc.c b/drivers/misc/mei/spi-vsc.c
index c30d9ee..95b36a1 100644
--- a/drivers/misc/mei/spi-vsc.c
+++ b/drivers/misc/mei/spi-vsc.c
@@ -35,6 +35,20 @@ static const struct acpi_gpio_mapping mei_vsc_acpi_gpios[] = {
 	{}
 };
 
+static int find_cvfd_child_adev_entry(struct acpi_device *adev, void *data)
+{
+	if (!strcmp(CVFD_ACPI_ID_TGL, acpi_device_hid(adev)) ||
+	    !strcmp(CVFD_ACPI_ID_ADL, acpi_device_hid(adev)) ||
+	    !strcmp(CVFD_ACPI_ID_RPL, acpi_device_hid(adev))) {
+		if (data)
+			*(struct acpi_device **)data = adev;
+
+		return 1;
+	}
+
+	return 0;
+}
+
 static struct acpi_device *find_cvfd_child_adev(struct acpi_device *parent)
 {
 	struct acpi_device *adev;
@@ -42,12 +56,16 @@ static struct acpi_device *find_cvfd_child_adev(struct acpi_device *parent)
 	if (!parent)
 		return NULL;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6,0,0))
 	list_for_each_entry (adev, &parent->children, node) {
-		if (!strcmp(CVFD_ACPI_ID_TGL, acpi_device_hid(adev)) ||
-		    !strcmp(CVFD_ACPI_ID_ADL, acpi_device_hid(adev)) ||
-		    !strcmp(CVFD_ACPI_ID_RPL, acpi_device_hid(adev)))
+		if (find_cvfd_child_adev_entry(adev, NULL))
 			return adev;
 	}
+#else
+	adev = NULL;
+	if (acpi_dev_for_each_child(parent, find_cvfd_child_adev_entry, &adev))
+		return adev;
+#endif
 
 	return NULL;
 }
